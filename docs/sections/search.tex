\section{Search strategy}

\subsection{Sequent representation}

During the preliminary rule generation, as well as during proof search, we need
to refer to subformulas of the goal sequent. It is important to remark that we
need to differentiate between two syntactically identical subformulas of
different formulas. For example

\[
  \zfneuseq{\cdot}{(p \otimes q) \otimes (p \otimes q),
    r \rightarrow (p \otimes q)}{\ctrlset{}}{p}
\]

Here, the \emph{same} formula $p \otimes q$ occurs three times as three
\emph{different} subformulas. To make this distinction clear during proof
search, as well as to have a way to easily refer and compare subformulas of the
goal sequent, we \emph{label} every subformula with a unique label.

We write $l \# A$ to denote that $l$ is the label for the formula $A$. Given a
goal sequent $\fneuseq{\Gamma}{\Delta}{Q}$, we label every \emph{non-atomic}
subformula of it sequent using a unique label (we consider atoms to be their own
labels). During proof search, we refer to labels only. In particular, all
derived rules refer to labelled sequents only.

\begin{definition}[Labelled sequents]
  A labelled sequent is a sequent of the form

  \[
    u_1, \dots, u_m ; l_1^{k_1}, \dots, l_n^{k_n} \fneuseqsymb_{\ctrlset{}} \gamma
  \]

  where $u_1, \dots, u_m$ are labels for unrestricted formulas, $l_1, \dots,
  l_n, \gamma$ are labels for linear formulas, and the $k_i$ in $l_i^{k_i}$ is
  the multiplicity of that label in the linear context.
\end{definition}

\subsection{Rules and rule application}

Derived rules are precomputed to specific frontier subformulas, or rather, to
the labels associated to frontier subformulas. Derived rules can be applied to
input sequents in different ways, as long as the input sequents satisfy the
sufficient requirements in order to be used with that rule. That is, to apply a
rule to an input sequent, we have to first \emph{match} a premise of the rule to
the input sequent. We formalize this in a notion of \emph{sequent schema}.

\begin{definition}[Sequent schema]
  A sequent schema is of the form

  \[
    u_1, \dots, u_m ; l_1^{k_1}, \dots, l_n^{k_n} \fneuseqsymb_{\zeta} \gamma
  \]

  where $\gamma$ is either a label $r$ or $\cdot$, and $\zeta$ is either a
  control set $\ctrlset{}$ or $\cdot$.
\end{definition}

\begin{definition}[Matching]
  We say that a schema $\sigma = \zfneuseq{\Gamma_s}{\Delta_s}{\zeta}{\gamma_s}$ matches
  an input sequent $s = \zfneuseq{\Gamma}{\Delta}{\ctrlset{}}{r}$ if

  \begin{enumerate}
  \item $\Gamma_s \subseteq \Gamma$;
  \item $\Delta_s \subseteq \Delta$;
  \item $\gamma_s = \cdot$ or $\gamma_s = r$;
  \item $\zeta = \cdot$ or $\zeta = \ctrlset{}$.
  \end{enumerate}
\end{definition}
\begin{definition}[Match result]
  A result of the match, written $\sigma | s$, is a sequent-like structure
  $\zfneuseq{\Gamma_r}{\Delta_r}{\zeta_r}{\gamma_r}$, for which

  \begin{enumerate}
  \item $\Gamma_r = \Gamma \setminus \Gamma_s$;
  \item $\Delta_r = \Delta \setminus \Delta_s$;
  \item $\gamma_r =
    \begin{cases}
      \cdot, & \text{if } \gamma_s = r \\
      r,     & \text{if } \gamma_s = \cdot
    \end{cases}$
  \item $\zeta_r =
    \begin{cases}
      \cdot, & \text{if } \zeta = r \\
      \ctrlset{},     & \text{if } \zeta = \cdot
    \end{cases}$
    % \item Like this in the thesis: $\gamma_r = \gamma$.
  \end{enumerate}
\end{definition}

\begin{example}
  Suppose we are deriving the rule associated to the formula $q \limp d \otimes
  d \otimes n$. The derivation can be expressed with the help of schematic
  variables as follows:

  {
    \scriptsize{
      \[
        \begin{prooftree}
          s
          \quad
          \[
            \justifies
            \frfrelj{q}{\cdot}{\fneuseq{\cdot}{q}{\cdot}}
          \]
          \,
          \[
            \[
              \justifies
              \factrelj{
                \bkwseq{d,d,n}{\cdot}{\cdot}
              }{
                s
              }{
                \zfneuseq{\Gamma_r}{\Delta_r}{\zeta_r}{\gamma_r}
              }
            \]
            \justifies
            \factrelj{
              \bkwseq{\cdot}{d \otimes d \otimes n}{\cdot}
            }{
              s
            }{
              \zfneuseq{\Gamma_r}{\Delta_r}{\zeta_r}{\gamma_r}
            }
          \]
          \justifies
          \zfneuseq{\Gamma_r, A_1}{\Delta_r, q}{\zeta_r}{\gamma_r}
        \end{prooftree}
      \]
    }
  }

  The sequent-like structure $\bkwseq{d,d,n}{\cdot}{\cdot}$ of the active
  relation acts as our sequent schema for the resulting derived rule.  It tells
  us that the premise sequent $s$ is required to include $d, d, n$ in its linear
  context. The goal $\gamma_r$ of the premise, whatever that is, then becomes
  the goal of the conclusion sequent of the derived rule. All this can be
  expressed in terms of sequent schemas, by saying that the premises of the
  above rule must be matched agains the schema

  \[
    \zfneuseq{\cdot}{d,d,n}{\cdot}{\cdot}
  \]

  Matching (with success) an input sequent $s$ against this schema will produce
  a result $\zfneuseq{\Gamma_r}{\Delta_r}{\zeta_r}{\gamma_r}$, from
  which the the conclusion sequent of the entire rule can be assembled:

  \[
    \zfneuseq{\Gamma_r, A_1}{\Delta_r, q}{\zeta_r}{\gamma_r}
  \]
\end{example}


\subsection{Search procedure}

% From 4.1.6

The search procedure for an input goal sequent
$\zsyseq{\Gamma}{\Delta}{\ctrlset{}}{C}$ is summarized as follows:

\begin{enumerate}
\item All subformulas of the goal sequent are labelled with unique label
  symbols, and decorate using signs and availabilities;
\item The frontier subformulas are computed and derived rules are generated from
  them. All derived rules with zero premises are treated as initial sequents;
\item Starting from the initial sequents, the derived inference rules are
  applied in any order that is guaranteed to saturate the search
  space. Conclusion sequents that are generated during these applications are
  stored and used as premises during the next iterations;
\item If a conclusion sequent $\zfneuseq{\Gamma'}{\Delta}{\ctrlset{}}{C}$ is
  found that subsumes the goal, that is $\Gamma' \subseteq \Gamma$, exit with
  success.
\item If the search space is saturated before finding a sequent that subsumes
  the goal, exit with failure.
\end{enumerate}

The procedure maintains two continually updated sequent databases:

\begin{enumerate}
\item The \strong{kept sequents} database, that contains new sequents that have not
  been encountered during previous iterations, but that are still to be
  considered for rule applications;
\item The \strong{active sequents} database, that contains all sequents that
  should be considered for rule applications.
\end{enumerate}

we follow the approach of [cmu thesis] and ``currify'' inference rules with
multiple premises. More precisely, we treat all rules as essentially unary rules
that produce either a conclusion sequent or a new, partially instantiated
rule. At the end of each iteration, all rules that have been partially but not
fully applied are added to the database of available rules for the next
iterations, which is therefore dynamically growing.

The loop of the search procedure repeats the following \emph{activation}
step until either the goal sequent is subsumed (in which case the search is
successful), or no further rules are applicable to the sequents in the acitve
set and the inactive set is exhausted (in which case the search saturates).

\begin{definition}[Activation]
  To activate the sequent $s$, i.e., to transfer it from the inactive to the
  active set, the following steps are performed:

  \begin{enumerate}
  \item The sequent $s$ is inserted into the active set;
  \item All available rules are applied to $s$. If these applications produce
    new rules, say a set $R$, then the following two steps are performed in a
    loop until there are no additions to $R$:

    \begin{enumerate}
    \item For every sequent $s'$ in the active set, every rule in $R$ is applied
      to $s'$;
    \item any new rules generated are added to $R$.
    \end{enumerate}

    Borrowing terminology from [cmu thesis], we call this two-steps loop the
    \emph{percolation} phase.
  \item The collection of rules $R$ is added to the set of rules;
  \item All sequents generated during the above applications are tested for
    subsumption against all previously generated sequents. All new
    sequents are then added to the inactive set.
  \end{enumerate}
\end{definition}

\begin{theorem}[Completeness of the search loop]
  Let $S_a, S_i$ be the active and inactive sets and $R$ the collection of rules
  of the search procedure before initiating iteration $i$. Suppose $r$ is a rule
  in $R$ and $s_1, s_2, \dots, s_n$ is an ordered list of sequents from
  $S_a \cup S_i$ that would, if matched agains $r$ in this order, produce a
  successful result. Then this match actually occurs, and the result of it added
  to the state of the search, during some iteration $j \geq i$.
\end{theorem}
\begin{proof}
  By induction on $n$. If $n = 0$, then the match occurs vacuously during any
  iteration from $i$ on. If the list is instead $n+1$ elements long, then
  clearly the first $n$ sequents in the list potentially match $r$ successfully,
  and by inductive hypothesis they are eventually matched agains $r$ producing a
  partially applied rule $r'$ during some iteration $j \geq i$. We split cases
  depending on whether $s_{n+1} \in S_a$ or $s_{n+1} \in S_i$ during such
  iteration $j$.

  \begin{itemize}
  \item If $s_{n+1} \in S_a$ during iteration $j$ (whether because it is added
    at the beginning of it or because it is in $S_a$ already), then the
    percolation phase ensures that $r'$ is also matched against
    $s_{n+1}$. Therefore, $r$ is fully applied to $s_1, \dots, s_{n+1}$ during
    iteration $j$, where $j \geq i$ by hypothesis;

  \item If $s_{n+1} \in S_i$ during iteration $j$, then $s_{n+1}$ is eventually
    selected for activation during some iteration $k > j$ and matched against
    all rules in the collection of rules at that moment. From the inductive
    hypothesis it follows that $r'$ is added in the collection of rules during
    iteration $j$, so it certainly is in this collection during iteration
    $k$. Therefore, $r'$ is matched agains $s_{n+1}$ during some iteration
    $k \geq i$, hence producing the result of matching $r$ against
    $s_1, \dots, s_{n+1}$ during such iteration.
  \end{itemize}
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../docs"
%%% End:
