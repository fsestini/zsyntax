\section{Checking}



\subsubsection{Implementation details}

To slightly reduce the complexity of the automatic deduction process, we make
the following assumption:

\[
  \Delta \models \nabla \wedge \Gamma, \Delta \not \models \Gamma, \nabla
  \implies \forall \Gamma'
  \supseteq \Gamma, \; \Gamma', \Delta \not \models \Gamma', \nabla
\]

In words, we assume that if a context $\Gamma$ is such that it inhibits a
reaction, then so do all contexts $\Gamma'$ that extend it.

\subsubsection{Implementation details}

The two propositions above allow us to implement the proof search phase as
follows:

\begin{enumerate}
\item A structurally acceptable proof $\pi$ is found;
\item The current world $w$ is extended with knowledge about all derivations
  of the form $\Gamma, A \models B$ in $\pi$, to yield an updated world $w'$;
\item The proof in finally checked against the updated world $w'$.
\end{enumerate}

Notice that different derivations of the form $\Gamma, A \models B$ in the same
proof may influence each other in how the world is extended, for example when an
instance of one is part of the subderivation of another. This mutual dependence
can be solved by considering a per-proof monotone operator defining a one-step
world extension, and repeatedly applying such operator until a fixed point is
reached.

\begin{definition}
  World assignments form a join-semilattice

  \[
    \mathcal{A} = \langle \mathcal{L} \times \mathcal{L} \to
    \mathcal{P}(\mathcal{L}_\odot), \leq, \sqcup \rangle
  \]

  where

  \[
    w_1 \leq w_2 \equiv \forall F_1, F_2, w_1(F_1,F_2) \subseteq w_2(F_1,F_2)
  \]

  \[
    (w_1 \sqcup w_2)(F_1, F_2) = w_1(F_1,F_2) \cup w_2(F_1,F_2)
  \]
\end{definition}

Notice that, since we assume $\mathcal{L}_{\odot}$ to be finite, the set
$\mathcal{L} \times \mathcal{L} \to \mathcal{P}(\mathcal{L}_\odot)$ is finite
and so $\mathcal{A}$ is also a complete lattice. In particular, is has a top
element.

The order theoretic properties of world assigments extend to worlds in the
obvious way.

\begin{definition}
  Worlds form a join-semilattice
  $\mathcal{W} = \langle W, \leq, \sqcup \rangle$, where

  \[
    (w_{\text{ctrl}1}, w_{\text{elem}1}) \leq
    (w_{\text{ctrl}2}, w_{\text{elem}2}) \equiv
    w_{\text{ctrl}1} \leq w_{\text{ctrl}2} \wedge
    w_{\text{elem}1} \leq w_{\text{elem}2}
  \]
  \[
    (w_{\text{ctrl}1}, w_{\text{elem}1}) \sqcup
    (w_{\text{ctrl}2}, w_{\text{elem}2}) =
    (w_{\text{ctrl}1} \sqcup w_{\text{ctrl}2}, w_{\text{elem}1} \sqcup w_{\text{elem}2})
  \]
\end{definition}

Being $\mathcal{W}$ equipped with a top element $\top$, we have the rather
trivial property that every monotonic function over $W$ has a fixed point.

Given a derivation $\pi$ and a world $w$, the one-step extension
$\textsf{extend}_{\pi}(w) \in W$ is inductively defined as follows:

\begin{enumerate}
\item Case $\pi$ is ...
\end{enumerate}

\begin{proposition}
  The extension operator $\textsf{extend}_{\pi} : W \rightarrow W$ is monotone.
\end{proposition}
\begin{proof}
  TODO...
\end{proof}

Thus, the world against which a proof $\pi$ is checked is
$w' = \bigsqcup \{ \textsf{extend}_{\pi}^n(w) \, | \, n \in N \}$.

--------------------------------------------------------------------------------




Checking is performed after derivation search, to check that the candidate
derivation respects the constraints imposed by the control sets involved.
Checking happens by first doing a recursive pass though the derivation tree,
annotating it with the appropriate control sets and at the same time generating
constraints on these sets. After this, the generated constraints are passed to a
constraint solver that either accepts or rejects the derivation based on whether
the input constraints are solvable or not.

The user is allowed to query goal sequents with unspecified control sets; the
overall query in then assumed to be the existentially quantified closure of such
goal. In the constraint solving phase, these unspecified sets are treated at
meta-variables, so that every implicational formula has unique meta-variables
for its control and biocore sets. We thus talk about control (biocore) set
\emph{schema}.

Given the impossibility to compute the set-theoretic union of control set
expressions involving meta-variables, union during this phase is represented in
a purely syntactic way, thus preserving information on the operands involved.

Hence control (biocore) set schemas, may be represented by actual sets,
meta-variables or unions:

\[
  \mathrm{CSS} ::= \{\dots\} \ | \ c \ | \ \mathrm{CSS} + \mathrm{CSS}
\]

\[
  \mathrm{BSS} ::= \{\dots\} \ | \ s \ | \ \mathrm{BSS} + \mathrm{BSS}
\]

where CSS (respectively BSS) stands for Control Set Schema (respectively Biocore
Set Schema).

\subsection{Constraints}

We distinguish between equational constraints and biological
constraints. Equational constraints are just equations between schemas that are
resolved during the contraint generation phase by unification. Biological
constraints arise from the side conditions of the rules involved in the
derivation and involve the ``respects'' relation.
We define the exact shape of these constraints by examining the rules from which
they may arise.

\begin{itemize}
\item $\copyrule$.

  \[
    \begin{prooftree}
      \zsyseq{\Gamma, A}{\Delta, A}{\css{}}{C}
      \justifies
      \zsyseq{\Gamma, A}{\Delta}{\css{}}{C}
      \using{\copyrule}
    \end{prooftree}
  \]

  This rule requires unifying the $A$ in the linear context with the $A$ in the
  unrestricted context. For example, if $A, B$ are atoms, the application below:

  \[
    \begin{prooftree}
      \zsyseq{\Gamma, A \limp_c^s B}{\Delta, A \limp_{\css{}}^{\bss{}} B}{\css{}'}{C}
      \justifies
      \zsyseq{\Gamma, A \limp_c^s B}{\Delta}{\css{}'}{C}
      \using{\copyrule}
    \end{prooftree}
  \]

  generates the constraints $s = \bss{}$ and $c = \css{}$.

\item $\otimes R$.

  \[
    \begin{prooftree}
      \zsyseq{\Gamma}{\Delta_1}{\css{1}}{A} \qquad
      \zsyseq{\Gamma}{\Delta_2}{\css{2}}{B}
      \justifies
      \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\css{1} + \css{2}}{A \otimes B}
      \using{}
    \end{prooftree}
  \]

  This rule generates the usual biological constraint
  $(\respects{\Delta_1}{\css{2}} \wedge
  \respects{B}{\css{1}}) \vee
  (\respects{\Delta_2}{\css{1}} \wedge \respects{A}{\css{2}})$.

\item $\limp R$.

  \[
    \begin{prooftree}
      \zsyseq{\Gamma}{\Delta, A}{\css{}}{B}
      \justifies
      \zsyseq{\Gamma}{\Delta}{\emptyset}{A \limp^{\biocore{\Delta}}_{\css{}}
        B}
    \end{prooftree}
  \]

  The formula $A \limp^{S}_{C} B$ appears in the goal sequent, so its
  decorations may either be actual sets of meta-variables.
  This leads to equational constraints of the form

  \[
    s = \biocore{\Delta}, \quad \{ ... \} = \biocore{\Delta}
  \]
  \[
    c = \css{}, \quad \{ ... \} = \css{}
  \]

  where $s$ and $c$ are meta-variables.

\item $\limp L$.

  \[
    \begin{prooftree}
      \zsyseq{\Gamma}{\Delta_1}{\css{1}}{A}\qquad
      \zsyseq{\Gamma}{\Delta_2, B}{\css{2}}{C}
      \justifies
      \zsyseq{\Gamma}{\Delta_1, \Delta_2, A \limp^{\bss{}}_{\css{}} B}{\css{} +
        \css{2}}{C}
    \end{prooftree}
  \]

  This rule generates the equational constraint $\css{1} = \emptyset$ and the
  biological constraint $\respects{\Delta_2}{\css{}}$.
\end{itemize}

All these constraints that may be generated are quite unproblematic, except for
the ones of the form $s = \bss{}$ or $c = \css{}$. The problem may arise, in
particular, when more than one of such constraints are generated.  Suppose
$s = s_1 + s_2$ and $s = s_3 + s_4 + s_5$ are generated. This requires solving
$s_1 + s_2 = s_3 + s_4 + s_5$, but it is unclear how to do that without trying
all possible solutions.

To solve this, we should observe that constraints of the form $s = \bss{}$ are
generated only when the implicational formula associated with the meta-variable
$s$ appears as the principal formula of a $\limp R$ or $\copyrule$ rule. To put
it in another way, the number of such constraints for every meta-variable $s$
corresponds to the number of $\limp R$ in the derivation that have that formula
as principal, plus the number of $\copyrule$ that have the same formula as
principal in the unrestricted context. It turns out that if the formula is
linear, i.e. is appears in the linear context of the goal sequent, there is at
most one place in the derivation where such formula is principal.

\begin{proposition}
  If the formula $A \limp B$ is in $\Delta$, then every derivation of the
  sequent $\bkwseq{\Gamma}{\Delta}{C}$ contains at most one application of the
  $\limp R$ rule where $A \limp B$ is principal.
\end{proposition}
\begin{proof}
  Straightforward induction on the derivation.
\end{proof}

Notice that here, as in the rest of this document, we distinguish between
formula and proposition. In particular, a context may contain many formulas
corresponding to the same proposition.
The above proposition obviously fails if the formula we consider comes from the
unrestricted context and contains meta-variables. Suppose we knew that
$\zsyseq{\Gamma}{\Delta_1, A}{\css{1}}{B}$ and
$\zsyseq{\Gamma}{\Delta_2, A}{\css{2}}{B}$, where
$\Gamma \equiv (A \limp^s_c B) \limp C$. Then, we may derive the following:

\[
  \begin{prooftree}
    \[
      \[
        \[ \justifies \zsyseq{\Gamma}{C}{\emptyset}{C} \] \qquad
        \[
          \zsyseq{\Gamma}{\Delta_1, A}{\css{1}}{B}
          \justifies
          \zsyseq{\Gamma}{\Delta_1}{\emptyset}{A \limp^{\biocore{\Delta_1}}_{\css{1}} B}
        \]
        \justifies
        \zsyseq{\Gamma}{(A \limp^s_c B) \limp C, \Delta_1}{}{C}
      \]
      \justifies
      \zsyseq{\Gamma}{\Delta_1}{}{C}
    \]
    \qquad
    \[
      \[
        \[ \justifies \zsyseq{\Gamma}{C}{\emptyset}{C} \] \qquad
        \[
          \zsyseq{\Gamma}{\Delta_2, A}{\css{2}}{B}
          \justifies
          \zsyseq{\Gamma}{\Delta_2}{\emptyset}{A \limp^{\biocore{\Delta_2}}_{\css{2}} B}
        \]
        \justifies
        \zsyseq{\Gamma}{(A \limp^s_c B) \limp C, \Delta_2}{}{C}
      \]
      \justifies
      \zsyseq{\Gamma}{\Delta_2}{}{C}
    \]
    \justifies
    \zsyseq{(A \limp^s_c B) \limp C}{\Delta_1, \Delta_2}{}{C \otimes C}
  \end{prooftree}
\]

Checking this example generates, among others, the constraints

\[
  s = \biocore{\Delta_1},\; s = \biocore{\Delta_2}
\]
\[
  c = \css{1}, \; c = \css{2}
\]

We may try to make this kind of situations less problematic by giving particular
attention to how unrestricted formulas are treated during both proof search and
checking, but we decided to keep things simple and just forbid implicational
formulas with uninstantiated meta-variables in the unrestricted context.

\subsection{Solving}

The output of the constraints generation phase is a collection of biological
constraints of the form

\[
  \plainrespects{\bss{}}{\css{}}
\]

Such constraints are recursively decomposed to simpler ones according to some
rewrite rules, until a basic form is reached. A basic form may be trivially
solvable, in which case it is simply removed, not solvable, or it may involve
meta-variables. Biocore meta-variables in basic constraints are instantiated to
$\emptyset$, whereas basic constraints involving control set meta-variables are
not processed further, but simply reported back to the user.

Basic biological constraints $BC$ are defined as follows:

\[
  B ::= \plainrespects{X}{Y} \quad | \quad \plainrespects{X}{c}
  \quad | \quad \plainrespects{s}{Y} \quad | \quad \plainrespects{s}{c}
\]

where $X, Y$ are sets of bioformulas, and $s, c$ are meta-variables.
A basic constraint of the form $\plainrespects{X}{Y}$ is solved iff
$X \cap Y = \emptyset$.
The following rewrite rules are used:

\begin{align*}
  \plainrespects{\bss{1} + \bss{2}}{\css{}}
  \; & \longrightarrow \; \plainrespects{\bss{1}}{\css{}},
    \plainrespects{\bss{2}}{\css{}} \\
  \plainrespects{\bss{}}{\css{1} + \css{2}}
  \; & \longrightarrow \; \plainrespects{\bss{}}{\css{1}},
       \plainrespects{\bss{}}{\css{2}}
\end{align*}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../docs"
%%% End:
