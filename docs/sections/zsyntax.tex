\section{Zsyntax}\label{sec:zsyntax}

\subsection{Introduction}

... TODO ...

\subsection{Controlled monotonicity}

The property that separates the calculus of Zsyntax from plain linear logic is
its concept of controlled monotonicity. In linear logic, implication is
monotonic since $A \vdash B$ implies $A \otimes C \vdash B \otimes C$ for any
$C$. Zsyntax preserves the characteristics of linear logic as a logic of
resources, but has a non-monotonic logical consequence relation, or rather one
where such monotonicity is normally allowed apart from some specified cases. In
this sense it is similar to other formalisms such as default logic [TODO add
reference]. In the following we only repeat some of the definitions in
\cite{adding-logic} on which the following sections built upon. Details and
examples on how Zsyntax deals with monotonicity can be found in
\cite{adding-logic}.

\begin{definition}[Zsyntax elementary bases]
  \begin{enumerate}
  \item An elementary base of a formula $A$ is a context
    $\Gamma \in \bioformulas^*$ defined inductively as follows:

    \begin{enumerate}
    \item If $A \in \bioformulas$, then $\Gamma = A$;
    \item If $A \equiv B \rightarrow C$, then $\Gamma$ is an elementary base of
      $A$ whenever $\Gamma, A \models B$ is known;
    \item If $A \equiv B \otimes C$, then $\Gamma = \Delta, \Delta'$ is an
      elementary base of $A$ whenever $\Delta$ and $\Delta'$ are, respectively,
      an elementary base for $A$ and $B$.
    \end{enumerate}

  \item Denote by $\elembases{A} \in \mathcal{P}(\bioformulas^*)$ the set of all
    elementary bases for the formula $A$;
  \item Given a Z-state $\Gamma = A_1, \dots, A_n$, let $\elembases{\Gamma}$ be
    the set of all Z-states $\Delta_1, \dots, \Delta_n$ such that $\Delta_i$ is
    in $\elembases{A}$ for all $i$.
  \end{enumerate}
\end{definition}

Notice that, given any context $\Gamma$, the set $\elembases{\Gamma}$ may change
over time as new theorems of the form $\Delta, A \models B$ are discovered.
Also notice that the definition of elementary base is not complete until we
define precisely what it means to \emph{know} that $\Gamma, A \models B$ (for
example, is this knowledge provided manually by the user or managed
automatically by the machine?). We leave this decision to the implementation
details.

\cite{adding-logic} then goes on to define control sets for conditionals
$A \rightarrow B$ in terms of elementary bases, calling them \emph{elementary
  control sets}.  In what follows, $\bioformulas^*$ denotes as usual the set of
strings of formulas of the bonding language (which are just Z-states formed by
formulas of the bonding language only.)

\begin{definition}
  The \emph{elementary control set}
  $\ctrlset{A \rightarrow B} \in \mathcal{P}(\bioformulas^*)$ associated with
  the conditional $A \rightarrow B$ can be defined as follows:

  \[
    \ctrlset{A \rightarrow B}^* = \{
    \Gamma \in \bioformulas^* \, | \, \exists \Delta \in \elembases{A \rightarrow
    B}
    \quad : \quad \Gamma, \Delta, A \not \models \Gamma, B \text{ is known}
    \}
  \]
\end{definition}

Again, this definition is incomplete unless we specify what it means to know
that $\Gamma, \Delta, A \not \models \Gamma, B$. Nevertheless, under this
definition, the controlled $\rightarrow$ elimination rule becomes the following:

\[
  \begin{prooftree}
    \Gamma, A \rightarrow B \, : \, \Gamma^* \cap \ctrlset{A\rightarrow B}^* =
    \emptyset
    \justifies
    \Gamma, B
  \end{prooftree}
\]

\subsection{Reasons for a different conditional operator}

In \cite{adding-logic}, the authors describe Zsyntax, a logical calculus for
biological reactions which from now on will be referred to as \znd{}. In the
sections that follow, we will define an alternative natural deduction calculus
that is strictly related to, albeit in some rather profound way different to,
the one given in \cite{adding-logic}.  The calculus is given in terms of its
annotated provability relation $\models$, as taking the rules of
\cite{adding-logic} and annotating them would have been less elegant.  The
purpose is to give a precise formalization of the logic that we intend to
implement in the sequent calculus, and at the same time clarify the similarities
(and differences) with the original formulation.

The fundamental difference between our natural deduction calculus \eznd{} and
\znd{} lies in a different kind of Z-conditional (linear implication) operator.
The reason is logical, and lies in an unsatisfactory asymmetry between
introduction and elimination rules of the conditional operator presended in
\cite{adding-logic}.

We now recall the definition of the Z-conditional operator in
\cite{adding-logic}, and illustrate how the one used here is different. The
introduction rule for the Z-conditional is given in \cite{adding-logic} as
follows:

\[
  \begin{prooftree}
    \Gamma, \Delta \qquad
    \[
      \Gamma, A
      \leadsto
      B
    \]
    \justifies
    A \rightarrow B, \Delta
  \end{prooftree}
\]

This rule introduces a particular \emph{instance} of $A \rightarrow B$.  Even
though the conclusion of the rule shows a generic forula $A \rightarrow B$, the
reason we have such a formula is because we know that a particular aggregate
$\Gamma$, with its particular elementary base, when paired with $A$ has a
transition to $B$. This transition (which is just a proof in the natural
deduction calculus) of course depends of the fact that the context in which this
transition is placed respects all control sets involved in it.

This introduction rule forgets all these details, as it unifies all proofs (or
reactions) of the form $\Gamma, A \vdash B$ under the type $A \rightarrow B$.
To be fair, information is not actually thrown away, as it is supposed to be
remembered as part of the control sets and elementary bases associated with the
type $A \rightarrow B$. This however does not solve the asymmetry between the
two rules. In fact, consider the elimination rule given in \cite{adding-logic}:

\[
  \begin{prooftree}
    \Gamma, A \rightarrow B \, : \, \elembases{\Gamma} \cap \ctrlset{A\rightarrow B}^* =
    \emptyset
    \justifies
    \Gamma, B
  \end{prooftree}
\]

From the definition of control set in \cite{adding-logic}, we have that the
deduction above is allowed only if the context $\Gamma$ ``respects'' the control
set $\ctrlset{A\rightarrow B}^*$, in the sense that it is forbidden if $\Gamma$
is known to block \emph{some instance} of $A \rightarrow B$, that is,
$\Gamma, \Delta, A \not \models B$ is known for \emph{some} $\Delta$.

To see how this definition clashes with the introduction rule, consider the
following example. Suppose we know that $\Gamma, A \vdash B$ in any possible
context. In other words, the control set that we may want to associate with this
reaction is empty, as it is always allowed to happen. Then, intuitively, it
should be possible to derive the following:

\[
  \begin{prooftree}
    \[
      \Gamma, A, \Delta \qquad
      \[
        \Gamma, A
        \leadsto
        B
      \]
      \justifies
      A \rightarrow B, A, \Delta
      \using{\rightarrow\mathcal{I}}
    \]
    \justifies
    B, \Delta
    \using{\rightarrow\mathcal{E}}
  \end{prooftree}
\]

as we know that the aggregate of type $A \rightarrow B$ is really $\Gamma$ is
disguise, therefore we also know that $\Delta$ does not interact with its
reaction with $A$.

Suppose now that we know that $\Delta, \nabla, A \not \models B$ for some
$\nabla$. In Zsyntax, this is sufficient to block the validity of the deduction
above, since $\Delta$ would then violate the control set for $A \rightarrow B$
(which refers to \emph{all} known transitions of type $A \rightarrow B$, and so
also the one involving $\nabla$.) That is, a \emph{global property} of the
biological aggregates of type $A \rightarrow B$, referenced by the elimination
rule, prevents us to deduce a theorem that we certainly know to be
\emph{locally} possible, because we know from the introduction rule that the
particular instance of $A \rightarrow B$ that we are eliminating comes form
$\Gamma$, which is not really affected by the presence of $\Delta$.

In essence, the Z-conditional described above is \emph{too general}, as it
implicitly contains an existential quantification: to introduce an element of
type $A \rightarrow B$ is to know that \emph{there exists} an aggregate that,
paired with $A$, transitions to $B$. To prove something by elimination on an
element of type $A \rightarrow B$ is to prove it without knowledge on which
aggregate was used to establish $A \rightarrow B$, that is, to prove it for an
arbitrary $A \rightarrow B$ (this indeed corresponds to considering all of them,
or at least all of them according to our knowledge of the system so far, as in
the elimination rule in \cite{adding-logic}).

If we translate the calculus into sequents as is, this asymmetry between local
instances and global properties, introduction and elimination rules, and thus
between right and left sequent rules, inevitably prevents an elegant cut-free
calculus to be found. To restore the symmetry, we decided to use a different
kind of implication, one that keeps explicit track of both the aggregate from
which it originated and the history of transitions that were used to establish
its validity.

Notice that, even though this new operator (given in the section that follows)
allows us to restore some form of symmetry between left and right rules, the
resulting logic is still intrinsically non-commutative, as the success of a
derivation depends on the order in which inference rules are used. This is of
course a property that we want our logical system to have, if deductions are to
represent biological reactions. The price to be paid is in the resulting proof
theory, which gets more complicated and lacks properties that more standard
logics have. As an example, despite what is said in \cite{adding-logic}, the
deduction theorem fails to hold even in plain Zsyntax. In particular

\[
  \Gamma \vdash A \rightarrow B \not\implies \Gamma, A \vdash B
\]

As an example, consider $\Gamma \equiv A, A \rightarrow B, B \otimes B
\rightarrow C$, where $A \rightarrow B$ is only allowed to be used if $B$ is not
in the context. Then, $\Gamma \vdash B \rightarrow C$ is easily proved by first
eliminating $A \rightarrow B$ and then introducting $B$ to prove the conclusion.
However, there is no way to prove $\Gamma, B \vdash C$, as the presence of $B$
prevents $A \rightarrow B$ to be used.

\subsection{An alternative Z-conditional operator}

Our calculus \eznd{} will replace the conditional operator in \znd{} with the
following:

\[
  A \rightarrow_{\reactlist{}}^S B
\]

where $A,B$ are formulas, $S$ is a set of atomic formulas of the bonding
language $\bioformulas$, and $l$ is a list defined in a suitable way. The
meaning of such annotations will become clear as we introduce the concepts.

The introduction of our modified conditional operator requires a new definition
of elementary base for a formula and for a (multi)set of formulas. Recall that
elementary bases in \cite{adding-logic} are sets of elementary contexts of
elements of the bonding language $\bioformulas$. Such definition is necessary,
as conditional operators of type $A \rightarrow B$ refer to \emph{all} known
reactions of such type. Since in our formalism there is a one-to-one
correspondence between an instance of a conditional operator and a known
reaction, we must redefine elementary bases with such \emph{locality} in mind.
For this reason, our elementary bases are just sets of formulas of the bonding
language, rather than sets of contexts.

\begin{definition}[Elementary base]
  The elementary base $\elembases{A} \subseteq \bioformulas$ of a formula $A$ is
  inductively defined as follows:

  \begin{enumerate}
  \item $\elembases{A} = \{ A \}$, if $A \in \bioformulas$;
  \item $\elembases{A \otimes B} = \elembases{A} \cup \elembases{B}$;
  \item $\elembases{A \rightarrow_{\reactlist{}}^S B} = S$.
  \end{enumerate}
\end{definition}

Control sets are defined as before, that is, as sets of linear contexts (lists)
of atomic formulas of the bonding language. We now define the type of lists that
will be used as part of conditional formulas.

\begin{definition}[Reaction list]
  \begin{enumerate}
  \item A \emph{reaction list} is a list of pairs where the first component is
    an elementary base, and the second component is a control set. Concatenation
    of reaction lists, written $\listplus{l_1}{l_2}$, is defined in the usual
    way;
  \item A context $\Delta$ is said to \emph{respect} a reaction list $l$,
    written $\resplist{\Delta}{l}$, if

    \[
      \forall (\nabla, \ctrlset{})\in l, \respects{\nabla, \Delta}{\ctrlset{}}
    \]

  \item The operation of adjoining an elementary base $\Delta$ to a reaction
    list $l$, written $\basepluslist{\Delta}{l}$, is recursively defined as
    follows:

    \begin{align*}
      \basepluslist{\Delta}{[]} &= [] \\
      \basepluslist{\Delta}{(\nabla;\ctrlset{}):l} &= (\Delta,\nabla;\ctrlset{}):\basepluslist{\Delta}{l}
    \end{align*}
  \end{enumerate}
\end{definition}

As the meaning of our conditional operator is tightly related to its
meta-linguistic counterpart, we posticipate giving its intuitive meaning until
the definition of the provability relation that we will consider, and the
related inference rules.

\subsection{The calculus \eznd{}}

We now give an alternative formalization of the rules of Zsyntax, that uses the
modified conditional operator.
As it will be clear, our modification yields a strictly stronger calculus with
respect to proofs involving conditionals, as reactions (as the one given in the
previous section) that are not provable in \znd{} will be in \eznd{}.

The resulting lack of soundness w.r.t. \znd{} is both obvious and not
problematic. Obvious since we have understood that the Z-conditional of \znd{}
and the one given here are of different strenghts (our being stronger), as
asserting that a particular reaction is valid is a stronger statement than just
asserting that one exists. It follows that some reactions that are provable in
\eznd{} will not be provable in \znd{}, simply because the logic of \znd{} is
not expressive enough. This leads to the reason why such lack of soundness is
not problematic, as more expressiveness is obviously better than less.  Having
said that, it is nevertheless reasonable to ask ourselves how to express Zsyntax
assertions in our language. We discuss this point after the detailed definition
of the calculus and the conditional operator.

\eznd{} proofs involve a judgement which is basically the provability relation
of Zsyntax as in \cite{adding-logic}, decorated with information about the
series of biological reactions that were used to establish the proof. Such
\emph{history} is represented in terms of the previously defined reaction lists.

\begin{definition}[Enhanced provability judgement]
  Enhanced provability judgements are judgements of the form

  \[
    \Gamma \models_{\reactlist{}} \Delta
  \]

  where $\Gamma, \Delta$ are lists of formulas, and $\reactlist{}$ is a reaction
  list.
\end{definition}

Here, the reaction list $l$ gives a kind of history of reactions that brought
from $\Gamma$ to $\Delta$: to a pair $(\nabla, \ctrlset{}) \in l$ we associate
the information that $\Gamma$, during its transition to become $\Delta$, reached
a Z-state which elementary base was $\nabla$, and used a transition with
control set $\ctrlset{}$ to advance to the next intermediate aggregate.
In other words, the reaction list $l$ keeps track of the intermediate forms that
$\Gamma$ assumed in its transition to $\Delta$, and the control sets of the
conditional formulas that allowed such intermediate reactions.

Hence, the intuitive meaning of affirming a judgement of the form
$\Delta \models_{\reactlist{}} \nabla$ is to know that there exists a sequence
of \eznd{} rule applications with which it is possible to reach the Z-state
$\Gamma, \nabla$ from the Z-state $\Gamma, \Delta$, for any $\Gamma$ that is
compatible to $l$, or \emph{respects} it. Intuitively, this means that $\Gamma$
does not interfere with any of the intermediate reactions that bring $\Delta$ to
$\nabla$.

The reaction list annotations on the conditional operator have the same meaning
as the ones used in the provability relation, as the former is just an object
language internalization of the latter, meta-linguistic concept.  Elementary
base annotations in a conditional formula, say $A \rightarrow^S B$, are instead
used to keep track of the real biological nature of the element of type
$A \rightarrow B$ that we are considering.
In particular, to know that $A \rightarrow^S B$ is true is to know that $S, A
\models B$. This interpretation justifies our definition of elementary base:
since an element of type $A \rightarrow^S B$ really represents an aggregate with
elementary base $S$, it makes perfect sense to consider $S$ as the elementary
base of $A \rightarrow^S B$.

We now take the calculus \znd{} given in \cite{adding-logic} as a model to define our
modified calculus \eznd{}, which will be formed by inference rules having as
premises and conclusion judgements of the form
$\Gamma \models_{\reactlist{}} \Delta$.

\paragraph{Empirical rules}

Empirical rules are not part of the calculus, but are treated as axioms as
hinted in Section [TODO] of \cite{adding-logic}. In our language, to postulate
that $A$ transitions to $B$ provided that the control set $\ctrlset{}$ is
respected can be done by affirming that the following formula is true in the
empty context:

\[
  A \rightarrow_{(\emptyset, \ctrlset{}):[]}^\emptyset B
\]

This is coherent with our interpretation of the annotations of conditional
operators. An axiom is indeed by definition true in the empty context (hence the
empty elementary base in the formula), and represents an atomic transition
(hence the empty elementary base in the reaction list, as an atomic transition
has no intermediate steps) which can happen unless $\ctrlset{}$ is respected
(hence the control set $\ctrlset{}$ in the reaction list.)

As axioms can be used \emph{ad libitum} in a proof, we need a way to introduce
them at any stage:

\[
  \begin{prooftree}
    A \ \text{axiom}
    \justifies
    \Gamma \models_{[]} \Gamma, A
  \end{prooftree}
\]

\paragraph{$\rightarrow$ introduction}

We have the following rule:

\[
  \begin{prooftree}
    \Gamma, A \models_{\reactlist{}} B
    \justifies
    \Gamma, \Delta \models_{[]}
    A \rightarrow_{\reactlist{}}^{\elembases{\Gamma}} B, \Delta
  \end{prooftree}
\]

Notice how the information on the reaction that was proved to establish the
truth of the conditional just introduced is preserved locally in the formula
itself. Also, notice how the empty reaction list in the conclusion represent the
fact that going from $\Gamma$ to $A \rightarrow B$ is just an act of renaming
rather than an actual biological reaction.

\paragraph{$\rightarrow$ elimination}

The rule in \cite{adding-logic}

\[
  \begin{prooftree}
    \Gamma, A \rightarrow B, A \; : \;
    \elembases{\Gamma} \cap \ctrlset{A \rightarrow B}^* = \emptyset
    \justifies
    \Gamma, B
  \end{prooftree}
\]

Can be translated to our formalism as follows:

\[
  \begin{prooftree}
    \resplist{\Gamma}{\reactlist{}}
    \justifies
    \Gamma, A \rightarrow_{\reactlist{}}^S B, A
    \models_{\basepluslist{\Gamma}{\reactlist{}}} \Gamma, B
  \end{prooftree}
\]

The intuition behind the reaction list in the conclusion is quite simple.  The
conditional witnesses the fact that we can transition from $A$ to $B$ with some
intermediate reactions $\reactlist{}$, in every context $\Gamma$ that respects
them. Therefore, we can safely add $\Gamma$ to the initial aggregate to get to
$\Gamma, B$ using the conditional at hand.

The reaction list of the overall transition that results from this is composed
of the initial reaction list $\reactlist{}$ of the conditional that has been
used, with the addition of (the elementary base of) $\Gamma$ in all its
components. This is to represent the fact that the intermediate reactions of the
conclusion are just those of $\reactlist{}$ with the addition of a passive
context $\Gamma$ alongside.

\paragraph{$\otimes$ introduction and elimination}

The $\otimes$ introduction and elimination rules are straighforward:

\[
  \begin{prooftree}
    \justifies
    \Gamma, A, B \models_{[]} \Gamma, A \otimes B
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \justifies
    \Gamma, A \otimes B \models_{[]} \Gamma, A, B
  \end{prooftree}
\]

\paragraph{Identity and composition}

Obviously, the trivial transition is allowed:

\[
  \begin{prooftree}
    \justifies
    \Gamma \models_{[]} \Gamma
  \end{prooftree}
\]

Moreover, in order to have the $\models$ relation represent arbitrary sequences
of Zsyntax rule applications, we need a way to compose such sequences:

\[
  \begin{prooftree}
    \Gamma \models_{\reactlist{1}} \Delta
    \qquad
    \Delta \models_{\reactlist{2}} \nabla
    \justifies
    \Gamma \models_{\listplus{\reactlist{1}}{\reactlist{2}}} \nabla
  \end{prooftree}
\]

We can formalize our intuition about reaction list annotations and controlled
monotonicity with the following rule:

\[
  \begin{prooftree}
    \Gamma \models_{\reactlist{}} \Delta
    \qquad
    \resplist{\nabla}{\reactlist{}}
    \justifies
    \Gamma, \nabla \models_{\basepluslist{\nabla}{\reactlist{}}} \Delta, \nabla
  \end{prooftree}
\]

which is obviously close, both in its form and in its justification, to the
$\rightarrow$ elimination rule. The admissibility of this rule is justified by a
simple examination of the rules of the calculus, so we skip a detailed
proof. Such proof, however, can be easily formalized as a much simpler version
of the cut elimination given in the next section.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../docs"
%%% End:
