\section{Backward sequent calculus}

\subsection{Blah...}

\begin{definition}[Reaction list]
  \begin{enumerate}
  \item A \emph{reaction list} is a list of pairs where the first component is
    an elementary base, and the second component is a control set. Concatenation
    of reaction lists, written $\listplus{l_1}{l_2}$, is defined in the usual
    way;
  \item A context $\Delta$ is said to \emph{respect} a reaction list $l$,
    written $\resplist{\Delta}{l}$, if

    \[
      \forall (\nabla, \ctrlset{})\in l, \respects{\nabla, \Delta}{\ctrlset{}}
    \]

  \item The operation of adjoining an elementary base $\Delta$ to a reaction
    list $l$, written $\basepluslist{\Delta}{l}$, is recursively defined as
    follows:

    \begin{align*}
      \basepluslist{\Delta}{[]} &= [] \\
      \basepluslist{\Delta}{(\nabla;\ctrlset{}):l} &= (\Delta,\nabla;\ctrlset{}):\basepluslist{\Delta}{l}
    \end{align*}
  \end{enumerate}

\end{definition}

\subsection{The rest...}

The objective of this section is to obtain a logic describing the modified
provability relation of \eznd{}, that is amenable to efficient proof search
while being sound and complete with \eznd{} itself. This basically means that we
are going to need some sort of sequent calculus enjoying properties like the
subformula property and cut admissibility.  Given the obvious similarities
between a Zsyntax proof and a proof in intuitionistic linear logic, it seems
reasonable to aim for a slightly modified version of the sequent calculus for
intuitionistic linear logic in our search for such a calculus. The rest of this
section does exactly that.

In what follows, we try to mold our sequent calculus rules into shape by
starting from what would be a direct translation of the rules of \eznd{} and
refining them into more standard form by cut. The aim is to get rules that
allow us to easily prove the subformula property and cut admissibility in a
later stage.

As premises and conclusions we have annotated sequents of the following form

\[
  \zsyseq{\Gamma}{\Delta}{l}{C}
\]

where $\Gamma$ is the \emph{unrestricted context}, namely one where contraction
and weakening are accepted, $\Delta$ is the usual linear context, and $l$ is a
reaction list. The intuitive explanation is that a valid sequent of this form
witnesses the fact that, under the set $\Gamma$ of biological axioms available
in $\Gamma$, there exists a sequence of Zsyntax transitions that bring the
aggregate $\Delta$ to the aggregate $C$. In particular, this reaction happens in
any context that respects the reaction list, that is, in any $\Delta'$ such that
$\resplist{\Delta'}{l}$. By soundness, the validity of the sequent above
expresses that we know that $\Delta \models_{l} C$ holds in \eznd{}.

Throughout the rest of the presentation, we assume that the set of axioms is
``harmful'', in the sense that $\elembases{\Gamma} = \emptyset$.
This is the same as saying that all formulas in $\Gamma$ must be conditionals
with an empty elementary base.

We now give the rules of the calculus. To do so, we assume to have the following
form of cut rule available, even though we do not really include in the
calculus. This is because it will be shown later to be admissible.

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta_1}{\reactlist{1}}{A}
    \qquad
    \zsyseq{\Gamma}{\Delta_2, A}{\reactlist{2}}{B}
    \justifies
    \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\listplus{\reactlist{1}}{\reactlist{2}}}{B}
    \using{\resplist{\Delta_2}{l_1}}
  \end{prooftree}
\]

\paragraph{Identity}

The trivial reaction is the one that does nothing:

\[
  \begin{prooftree}
    \justifies
    \zsyseq{\Gamma}{A}{[]}{A}
  \end{prooftree}
\]

It can be proved that we can rescrict $A$ to the atomic case while retaining
completeness.

\paragraph{Biological axioms}

The calculus has a built-in way to account for (biological) axioms with the
unrestricted context. To make an axiom $A$ available to a derivation, it
sufficies to take it from the unrestricted context and add it to the linear
context. Formulas in the unrestricted context can of course be used ad libitum:

\[
  \begin{prooftree}
    \zsyseq{\Gamma, A}{\Delta, A}{\reactlist{}}{C}
    \justifies
    \zsyseq{\Gamma, A}{\Delta}{\reactlist{}}{C}
  \end{prooftree}
\]

\paragraph{$\otimes$ elimination}

A direct translation from Zsyntax yields a rule that is already in an acceptable
form for a left rule.

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta, A, B}{l}{C}
    \justifies
    \zsyseq{\Gamma}{\Delta, A \otimes B}{l}{C}
  \end{prooftree}
\]

\paragraph{$\otimes$ introduction}

The $\otimes$ introduction rule of the original calculus is the exact inverse of
the elimination rule, so a direct translation from Zsyntax to sequent calculus
would be the following:

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta, A \otimes B}{\reactlist{}}{C}
    \justifies
    \zsyseq{\Gamma}{\Delta, A, B}{\reactlist{}}{C}
  \end{prooftree}
\]

This, however, is not a good rule as it augments the complexity of the sequent,
and breaks the left-right symmetry. We first notice that the above rule and the
following axiom are equivalent

\[
  \begin{prooftree}
    \justifies
    \zsyseq{\Gamma}{A,B}{[]}{A \otimes B}
  \end{prooftree}
\]

The second comes from the first by identity. The first comes from the second by
cut:

\[
  \begin{prooftree}
    \[ \justifies \zsyseq{\Gamma}{A,B}{[]}{A \otimes B} \]
    \qquad
    \zsyseq{\Gamma}{\Delta, A \otimes B}{\reactlist{}}{C}
    \justifies
    \zsyseq{\Gamma}{\Delta, A, B}{\reactlist{}}{C}
  \end{prooftree}
\]

However, we have to do some additional cuts to the axiom above in order to
obtain something that allows us to eliminate the cut rule later.


\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta_2}{[]}{B} \qquad
    \[
      \zsyseq{\Gamma}{\Delta_1}{[]}{A} \qquad
      \[\justifies \zsyseq{\Gamma}{A,B}{[]}{A \otimes B} \]
      \justifies
      \zsyseq{\Gamma}{\Delta_1, B}{[]}{A \otimes B}
    \]
    \justifies
    \zsyseq{\Gamma}{\Delta_1, \Delta_2}{[]}{A \otimes B}
  \end{prooftree}
\]

thus yielding the following rule

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta_1}{[]}{A} \qquad
    \zsyseq{\Gamma}{\Delta_2}{[]}{B}
    \justifies
    \zsyseq{\Gamma}{\Delta_1, \Delta_2}{[]}{A \otimes B}
  \end{prooftree}
\]


% There are actually two
% ways to do it (yielding in essence two different rules), but this is just a
% consequence of the fact that Zsyntax is aware of the ordering in which
% deductions (i.e., reactions) are performed.

% \[
%   \begin{prooftree}
%     \zsyseq{\Gamma}{\Delta_2}{\ctrlset{2}}{B} \qquad
%     \[
%       \zsyseq{\Gamma}{\Delta_1}{\ctrlset{1}}{A} \qquad
%       \[\justifies \zsyseq{\Gamma}{A,B}{\emptyset}{A \otimes B} \]
%       \justifies
%       \zsyseq{\Gamma}{\Delta_1, B}{\ctrlset{1}}{A \otimes B}
%       \using{\respects{B}{\ctrlset{1}}}
%     \]
%     \justifies
%     \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\ctrlset{1} \cup \ctrlset{2}}{A \otimes B}
%     \using{\respects{\Delta_1}{\ctrlset{2}}}
%   \end{prooftree}
% \]

% thus yielding the following rule

% \[
%   \begin{prooftree}
%     \zsyseq{\Gamma}{\Delta_1}{\ctrlset{1}}{A} \qquad
%     \zsyseq{\Gamma}{\Delta_2}{\ctrlset{2}}{B}
%     \justifies
%     \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\ctrlset{1} \cup \ctrlset{2}}{A \otimes B}
%     \using{\respects{\Delta_1}{\ctrlset{2}} \wedge \respects{B}{\ctrlset{1}}}
%   \end{prooftree}
% \]

% Or


% \[
%   \begin{prooftree}
%     \zsyseq{\Gamma}{\Delta_1}{\ctrlset{1}}{A} \qquad
%     \[
%       \zsyseq{\Gamma}{\Delta_2}{\ctrlset{2}}{B} \qquad
%       \[\justifies \zsyseq{\Gamma}{A,B}{\emptyset}{A \otimes B} \]
%       \justifies
%       \zsyseq{\Gamma}{\Delta_2, A}{\ctrlset{2}}{A \otimes B}
%       \using{\respects{A}{\ctrlset{2}}}
%     \]
%     \justifies
%     \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\ctrlset{1} \cup \ctrlset{2}}{A \otimes B}
%     \using{\respects{\Delta_2}{\ctrlset{1}}}
%   \end{prooftree}
% \]

% thus yielding the following rule

% \[
%   \begin{prooftree}
%     \zsyseq{\Gamma}{\Delta_1}{\ctrlset{1}}{A} \qquad
%     \zsyseq{\Gamma}{\Delta_2}{\ctrlset{2}}{B}
%     \justifies
%     \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\ctrlset{1} \cup \ctrlset{2}}{A \otimes B}
%     \using{\respects{\Delta_2}{\ctrlset{1}} \wedge \respects{A}{\ctrlset{2}}}
%   \end{prooftree}
% \]

\paragraph{$\rightarrow$ introduction}

A direct translation to our single-succedent sequent calculus would be the
following:

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta_1, A}{\reactlist{1}}{B} \qquad
    \zsyseq{\Gamma}{\Delta_2, A \rightarrow^{\elembases{\Delta_1}}_{\reactlist{1}}
      B}{\reactlist{2}}{C}
    \justifies
    \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\reactlist{2}}{C}
  \end{prooftree}
\]

However, this rule again has the drawback that it increases the complexity of
the sequent backwards, and breaks the left-right symmetry. A better, more
standard rule can be obtained as a special case of the one above:

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta_1, A}{\reactlist{1}}{B}
    \qquad
    \zsyseq{\Gamma}{A \rightarrow^{\elembases{\Delta_1}}_{\reactlist{1}}
      B}{[]}{A \rightarrow^{\elembases{\Delta_1}}_{\reactlist{1}}
      B}
    \justifies
    \zsyseq{\Gamma}{\Delta_1}{[]}{A \rightarrow^{\elembases{\Delta_1}}_{\reactlist{1}}
      B}
  \end{prooftree}
\]

thus yielding the following:

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta, A}{\reactlist{}}{B}
    \justifies
    \zsyseq{\Gamma}{\Delta}{[]}{A \rightarrow^{\elembases{\Delta}}_{\reactlist{}}
      B}
  \end{prooftree}
\]

The equivalence is witnessed by the fact that the first rule can be obtained
from the second by cut:

\[
  \begin{prooftree}
    \[
      \zsyseq{\Gamma}{\Delta_1, A}{\reactlist{1}}{B}
      \justifies
      \zsyseq{\Gamma}{\Delta}{[]}{A \rightarrow^{\elembases{\Delta_1}}_{\reactlist{1}}
        B}
    \]
    \qquad
    \zsyseq{\Gamma}{\Delta_2, A \rightarrow^{\elembases{\Delta_1}}_{\reactlist{1}}
      B}{\reactlist{2}}{C}
    \justifies
    \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\reactlist{2}}{C}
  \end{prooftree}
\]

\paragraph{$\rightarrow$ elimination}

The direct translation would be the following:

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta, B}{\reactlist{}'}{C}
    \justifies
    \zsyseq{\Gamma}{\Delta, A \rightarrow^{\elembases{S}}_{\reactlist{}}
      B, A}{\listplus{\basepluslist{\Delta}{\reactlist{}}}{\reactlist{}'}}{C}
    \using{\resplist{\Delta}{\reactlist{}}}
  \end{prooftree}
\]

We can get to a better left rule that has only the implication as principal
formula with cut:


\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta_1}{[]}{A}\qquad
    \[
      \zsyseq{\Gamma}{\Delta_2, B}{\reactlist{2}}{C}
      \justifies
      \zsyseq{\Gamma}{\Delta_2, A \rightarrow^{\elembases{S}}_{\reactlist{1}}
        B, A}{\listplus{\basepluslist{\Delta_2}{\reactlist{1}}}{\reactlist{2}}}{C}
      \using{\resplist{\Delta_2}{\reactlist{1}}}
    \]
    \justifies
    \zsyseq{\Gamma}{\Delta_1, \Delta_2, A
      \rightarrow^{\elembases{S}}_{\reactlist{1}} B}{
      \listplus{\basepluslist{\Delta_2}{\reactlist{1}}}{\reactlist{2}}
      }{C}
  \end{prooftree}
\]

thus yielding the following rule:

\[
  \begin{prooftree}
    \zsyseq{\Gamma}{\Delta_1}{[]}{A}\qquad
    \zsyseq{\Gamma}{\Delta_2, B}{\reactlist{2}}{C}
    \justifies
    \zsyseq{\Gamma}{\Delta_1, \Delta_2, A
      \rightarrow^{\elembases{S}}_{\reactlist{1}} B}{
      \listplus{\basepluslist{\Delta_2}{\reactlist{1}}}{\reactlist{2}}
      }{C}
    \using{
      \resplist{\Delta_2}{\reactlist{1}}}
  \end{prooftree}
\]

The resulting sequent calculus is given in full in Figure~\ref{bkwseqcalc}.

\begin{figure}[ht]
  \begin{mdframed}

    \[
      \begin{prooftree}
        \justifies
        \zsyseq{\Gamma}{A}{[]}{A}
        \using{\init}
      \end{prooftree}
      \qquad \qquad
      \begin{prooftree}
        \zsyseq{\Gamma, A}{\Delta, A}{\reactlist{}}{C}
        \justifies
        \zsyseq{\Gamma, A}{\Delta}{\reactlist{}}{C}
        \using{\copyrule}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \zsyseq{\Gamma}{\Delta_1}{[]}{A} \qquad
        \zsyseq{\Gamma}{\Delta_2}{[]}{B}
        \justifies
        \zsyseq{\Gamma}{\Delta_1, \Delta_2}{[]}{A \otimes B}
        \using{\otimes R}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \zsyseq{\Gamma}{\Delta, A \otimes B}{\reactlist{}}{C}
        \justifies
        \zsyseq{\Gamma}{\Delta, A, B}{\reactlist{}}{C}
        \using{\otimes L}
      \end{prooftree}
      \qquad \qquad
      \begin{prooftree}
        \zsyseq{\Gamma}{\Delta, A}{\reactlist{}}{B}
        \justifies
        \zsyseq{\Gamma}{\Delta}{[]}{A \limp^{\elembases{\Delta}}_{\reactlist{}}
          B}
        \using{\rightarrow R}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \zsyseq{\Gamma}{\Delta_1}{[]}{A}\qquad
        \zsyseq{\Gamma}{\Delta_2, B}{\reactlist{2}}{C}
        \qquad \resplist{\Delta_2}{\reactlist{1}}
        \justifies
        \zsyseq{\Gamma}{\Delta_1, \Delta_2, A \rightarrow^{S}_{\reactlist{1}} B}{
          \listplus{\basepluslist{\Delta_2}{\reactlist{1}}}{\reactlist{2}}}{C}
        \using{\rightarrow L}
      \end{prooftree}
    \]

  \end{mdframed}
  \caption{\label{bkwseqcalc} Annotated backward sequent calculus \zss{}.}
\end{figure}

\begin{lemma}[Identity expansion]
  The calculus \zss{}' with identity axiom allowing arbitrary formulas is
  equivalent to the calculus \zss{} with identity axiom restricted to atomic
  formulas.
\end{lemma}
\begin{proof}
  By induction on the derivations. There are as many cases as there are
  connectives to consider.

  \begin{enumerate}
  \item Case $\zsyseq{\Gamma}{A \otimes B}{[]}{A \otimes B}$. Then,

    \[
      \begin{prooftree}
        \[
          \zsyseq{\Gamma}{A}{[]}{A}
          \qquad
          \zsyseq{\Gamma}{B}{[]}{B}
          \justifies
          \zsyseq{\Gamma}{A, B}{[]}{A \otimes B}
          \using{\otimes R}
        \]
        \justifies
        \zsyseq{\Gamma}{A \otimes B}{[]}{A \otimes B}
        \using{\otimes L}
      \end{prooftree}
    \]

  \item Case $\zsyseq{\Gamma}{A \rightarrow_{\reactlist{}}^S B}{[]}{A
      \rightarrow_{\reactlist{}}^S B}$. Then, the following holds

    \[
      \begin{prooftree}
        \[
          \zsyseq{\Gamma}{A}{[]}{A}\qquad
          \zsyseq{\Gamma}{B}{[]}{B}
          \justifies
          \zsyseq{\Gamma}{A \rightarrow_{\reactlist{}}^S B, A}{\reactlist{}}{B}
        \]
        \justifies
        \zsyseq{\Gamma}{A \rightarrow_{\reactlist{}}^S B}{[]}{A
          \rightarrow_{\reactlist{}}^S B}
      \end{prooftree}
    \]

    since $\elembases{A \rightarrow^S_{\reactlist{}} B} = S$ and
    $\listplus{\basepluslist{\emptyset}{l}}{[]} = l$.
  \end{enumerate}
\end{proof}

\begin{theorem}[Cut admissibility]
  The following cut rule

  \[
    \begin{prooftree}
      \zsyseq{\Gamma}{\Delta_1}{\reactlist{1}}{A}
      \qquad
      \zsyseq{\Gamma}{\Delta_2, A}{\reactlist{2}}{B}
      \justifies
      \zsyseq{\Gamma}{\Delta_1, \Delta_2}{
        \listplus{\basepluslist{\Delta_2}{\reactlist{1}}}{\reactlist{2}}}{B}
      \using{\resplist{\Delta_2}{\reactlist{1}}}
    \end{prooftree}
  \]

  is admissible.
\end{theorem}
\begin{proof}
  The proof is inspired by the one given in [paper] for the full linear
  logic. In particular, we consider four ``classes'' of cuts and show
  admissibility for all of them. The theorem follows from the fact that these
  four classes cover all possible uses of the cut rule.
  We sometimes omit the side conditions about reaction lists and control sets
  when trivially satisfied.

  \begin{description}
  \item[Identity cuts] One of the premises is obtained by an application of the
    identity axiom.

    \begin{enumerate}
    \item Left case.

      \[
        \begin{prooftree}
          \[ \justifies \zsyseq{\Gamma}{A}{[]}{A} \]
          \qquad
          \zsyseq{\Gamma}{\Delta_2, A}{\reactlist{2}}{B}
          \justifies
          \zsyseq{\Gamma}{A, \Delta_2}{\reactlist{2}}{B}
        \end{prooftree}
      \]

      Then, just take the second premise.

    \item Right case.

      \[
        \begin{prooftree}
          \zsyseq{\Gamma}{\Delta_1}{\reactlist{1}}{A}
          \qquad
          \zsyseq{\Gamma}{A}{[]}{A}
          \justifies
          \zsyseq{\Gamma}{\Delta_1}{\reactlist{1}}{A}
        \end{prooftree}
      \]

      Then, just take the first premise.
    \end{enumerate}
  \item[Principal cuts] The cut formula is principal in both premises. We
    distinguish the two possible cases of non-atomic formulas.

    \begin{enumerate}
    \item Case $\otimes$.


      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_1}{[]}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_2}{[]}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_2}{[]}{A \otimes B}
          \]
          \qquad
          \[
            \zsyseq{\Gamma}{\Delta_3, A, B}{\reactlist{}}{C}
            \justifies
            \zsyseq{\Gamma}{\Delta_3, A \otimes B}{\reactlist{}}{C}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\reactlist{}}{C}
        \end{prooftree}
      \]

      Then, by inductive hypothesis, we have

      \[
        \begin{prooftree}
          \zsyseq{\Gamma}{\Delta_2}{[]}{B}
          \qquad
          \[
            \zsyseq{\Gamma}{\Delta_1}{[]}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_3, A, B}{\ctrlset{}}{C}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_3, B}{\ctrlset{}}{C}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\ctrlset{}}{C}
        \end{prooftree}
      \]

    \item Case $\rightarrow_{\reactlist{}}^S$.

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_1, A}{\reactlist{1}}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta_1}{[]}{A \rightarrow_{\reactlist{1}}^{\elembases{\Delta_1}} B}
          \]
          \qquad
          \[
            \zsyseq{\Gamma}{\Delta_2}{[]}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_3, B}{\reactlist{2}}{C}
            \justifies
            \zsyseq{\Gamma}{\Delta_2, \Delta_3, A
              \rightarrow_{\reactlist{1}}^{\elembases{\Delta_1}}
              B}{\baseandplus{\Delta_3}{\reactlist{1}}{\reactlist{2}}}{C}
            \using{\resplist{\Delta_3}{\reactlist{1}}}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2, \Delta_3}{
            \baseandplus{\Delta_3}{\reactlist{1}}{\reactlist{2}}
          }{C}
        \end{prooftree}
      \]

      Then, by inductive hypothesis, we have

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_2}{[]}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_1, A}{\reactlist{1}}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_2}{\reactlist{1}}{B}
          \]
          \quad
          \zsyseq{\Gamma}{\Delta_3, B}{\reactlist{2}}{C}
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2, \Delta_3}{
            \baseandplus{\Delta_3}{\reactlist{1}}{\reactlist{2}}
          }{C}
          \using{\resplist{\Delta_3}{\reactlist{1}}}
        \end{prooftree}
      \]

    \end{enumerate}
  \item[Left-commutative cuts] The cut formula is a side formula in the left
    premise. The cut is then simply moved up to the premises, where the
    inductive hypothesis is used.

    \begin{enumerate}
    \item Case $\otimes L$.

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_1, C, D}{\reactlist{1}}{A}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, C \otimes D}{\reactlist{1}}{A}
            \using{\otimes L}
          \]
          \qquad
          \zsyseq{\Gamma}{\Delta_2, A}{\reactlist{2}}{B}
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2, C \otimes D}{
            \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
          }{B}
          \using{\resplist{\Delta_2}{\reactlist{1}}}
        \end{prooftree}
      \]

      becomes

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_1, C, D}{\reactlist{1}}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_2, A}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_2, C, D}{
              \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
            }{B}
            \using{\resplist{\Delta_2}{\reactlist{1}}}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2, C \otimes D}{
            \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
          }{B}
          \using{\otimes L}
        \end{prooftree}
      \]

    \item Case $\copyrule$.

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma, C}{\Delta_1, C}{\reactlist{1}}{A}
            \justifies
            \zsyseq{\Gamma, C}{\Delta_1}{\reactlist{1}}{A}
          \]
          \qquad
          \zsyseq{\Gamma, C}{\Delta_2, A}{\reactlist{2}}{B}
          \justifies
          \zsyseq{\Gamma, C}{\Delta_1, \Delta_2}{
            \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
          }{B}
          \using{\resplist{\Delta_2}{\reactlist{1}}}
        \end{prooftree}
      \]

      becomes

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma, C}{\Delta_1, C}{\reactlist{1}}{A}
            \qquad
            \zsyseq{\Gamma, C}{\Delta_2, A}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma, C}{\Delta_1, C, \Delta_2}{
              \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
            }{B}
            \using{\resplist{\Delta_2}{\reactlist{1}}}
          \]
          \justifies
          \zsyseq{\Gamma, C}{\Delta_1, \Delta_2}{
            \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
          }{B}
          \using{\copyrule}
        \end{prooftree}
      \]

    \item Case $\rightarrow L$.

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_1}{[]}{C}
            \qquad
            \zsyseq{\Gamma}{\Delta_2, D}{\reactlist{1}}{A}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_2, C \rightarrow_{\reactlist{}}^S D
            }{
              \baseandplus{\Delta_2}{\reactlist{}}{\reactlist{1}}
            }{A}
            \using{\resplist{\Delta_2}{\reactlist{}}}
          \]
          \quad
          \zsyseq{\Gamma}{\Delta_3, A}{\reactlist{2}}{B}
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2, \Delta_3, C
            \rightarrow_{\reactlist{}}^S D}{
            \baseandplus{\Delta_3}{(\baseandplus{\Delta_2}{\reactlist{}}{\reactlist{1}})}{l_2}
          }{B}
          \using{
            \resplist{\Delta_3}{
              (\baseandplus{\Delta_2}{\reactlist{}}{\reactlist{1}})}
          }
        \end{prooftree}
      \]

      Since
      $\resplist{\Delta_3}{
        (\baseandplus{\Delta_2}{\reactlist{}}{\reactlist{1}})}$, we also have
      $\resplist{\Delta_3}{ \reactlist{1}}$. Therefore,

      \[
        \begin{prooftree}
          \zsyseq{\Gamma}{\Delta_1}{[]}{C}
          \quad
          \[
            \zsyseq{\Gamma}{\Delta_2, D}{\reactlist{1}}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_3, A}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta_2, \Delta_3, D}{
              \baseandplus{\Delta_3}{\reactlist{1}}{\reactlist{2}}
            }{A}
            \using{\resplist{\Delta_3}{ \reactlist{1}}}
          \]
          \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_2, \Delta_3, C
            \rightarrow_{\reactlist{}}^S D}{
            \baseandplus{(\Delta_2,\Delta_3)}{l}{(\baseandplus{\Delta_3}{\reactlist{1}}{\reactlist{2}})}
          }{B}
        \end{prooftree}
      \]

      Notice that the equivalences below follow by set theory and predicate
      logic, and by associativity of list concatenation:

      \begin{align*}
        \baseandplus{(\Delta_2,\Delta_3)}{l}{(\baseandplus{\Delta_3}{\reactlist{1}}{\reactlist{2}})}
        & = \listplus{
          (\baseandplus{(\Delta_2,\Delta_3)}{l}{\basepluslist{\Delta_3}{\reactlist{1}}})
          }{
          \reactlist{2}
          } \\
        & = \listplus{
          (
          \basepluslist{\Delta_3}{(\baseandplus{\Delta_2}{\reactlist{}}{\reactlist{1}})}
          %\baseandplus{(\Delta_2,\Delta_3)}{l}{\basepluslist{\Delta_3}{\reactlist{1}}}
          )
          }{
          \reactlist{2}
          }
      \end{align*}

      Hence the thesis.

    \end{enumerate}

  \item[Right-commutative cuts] The cut formula is a side formula in the right
    premise.

    \begin{enumerate}
    \item Case $\otimes L$.

      \[
        \begin{prooftree}
          \zsyseq{\Gamma}{\Delta_1}{\reactlist{1}}{A}
          \qquad
          \[
            \zsyseq{\Gamma}{\Delta_2, C, D, A}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta_2, C \otimes D, A}{\reactlist{2}}{B}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2, C \otimes D}{
            \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
          }{B}
          \using{\resplist{(\Delta_2, C \otimes D)}{\reactlist{1}}}
        \end{prooftree}
      \]

      Recalling the definition of elementary base, we have
      $\elembases{\Delta_2, C\otimes D} = \elembases{\Delta_2, C, D}$, hence
      $C\otimes D$ and $C,D$ are safely interchangeable in every context
      above. Therefore, we have


      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_1}{\reactlist{1}}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_2, C, D, A}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_2, C, D}{
              \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
            }{B}
            \using{\resplist{(\Delta_2, C, D)}{\reactlist{1}}}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2, C \otimes D}{
            \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
          }{B}
        \end{prooftree}
      \]

    \item Case $\copyrule$.


      \[
        \begin{prooftree}
          \zsyseq{\Gamma,C}{\Delta_1}{\reactlist{1}}{A}
          \qquad
          \[
            \zsyseq{\Gamma,C}{\Delta_2, C, A}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma,C}{\Delta_2, A}{\reactlist{2}}{B}
            \using{\copyrule}
          \]
          \justifies
          \zsyseq{\Gamma,C}{\Delta_1, \Delta_2}{
            \baseandplus{\Delta_2}{\reactlist{1}}{\reactlist{2}}
          }{B}
          \using{\resplist{\Delta_2}{\reactlist{1}}}
        \end{prooftree}
      \]

      Then, by inductive hypothesis, we have

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma,C}{\Delta_1}{\reactlist{1}}{A}
            \qquad
            \zsyseq{\Gamma,C}{\Delta_2, C, A}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma,C}{\Delta_2, C}{
              \baseandplus{(\Delta_2, C)}{\reactlist{1}}{\reactlist{2}}
            }{B}
            \using{\resplist{(\Delta_2, C)}{\reactlist{1}}}
          \]
          \justifies
          \zsyseq{\Gamma,C}{\Delta_1, \Delta_2}{
            \baseandplus{(\Delta_2, C)}{\reactlist{1}}{\reactlist{2}}
          }{B}
          \using{\copyrule}
        \end{prooftree}
      \]

      Recall that, by assumption, every formula $C$ in the unrestricted context
      is such that $\elembases{C} = \emptyset$. In particular, this means that
      $\Delta_2,C$ is equivalent to $\Delta_2$ in every context of the original
      derivation, since $\elembases{\Delta_2,C} = \elembases{\Delta_2}$. It
      follows that the derivation above is clearly valid.

    \item Case $\rightarrow L$.

      We can assume the cut formula to be active in the left premise, for
      otherwise we would treat the cut as a left-commutative case.  Then, the
      left premise must be the conclusion of either a $\rightarrow R$ or a
      $\otimes R$ rule. Both rules conclude with an empty list, so we can assume
      the list of the left premise to be empty. We distinguish two cases based
      on the position of the cut formula in the derivation of right premise.

      \begin{enumerate}
      \item Case the cut formula ends up in the left premise of the cut.
        \[
          \begin{prooftree}
            \zsyseq{\Gamma}{\Delta}{[]}{A}
            \qquad
            \[
              \zsyseq{\Gamma}{\Delta_1, A}{[]}{C}
              \qquad
              \zsyseq{\Gamma}{\Delta_2, D}{\reactlist{2}}{B}
              \justifies
              \zsyseq{\Gamma}{\Delta_1, \Delta_2, A, C \rightarrow_{\reactlist{}}^S
                D}{
                \baseandplus{\Delta_2}{\reactlist{}}{\reactlist{2}}
              }{B}
              \using{\resplist{\Delta_2}{\reactlist{}}}
            \]
            \justifies
            \zsyseq{\Gamma}{\Delta, \Delta_1, \Delta_2,
              C \rightarrow_{\reactlist{}}^S D
            }{
              \baseandplus{\Delta_2}{\reactlist{}}{\reactlist{2}}
            }{B}
          \end{prooftree}
        \]

        Then, by inductive hypothesis

        \[
          \begin{prooftree}
            \[
              \zsyseq{\Gamma}{\Delta}{[]}{A}
              \qquad
              \zsyseq{\Gamma}{\Delta_1, A}{[]}{C}
              \justifies
              \zsyseq{\Gamma}{\Delta, \Delta_1}{[]}{C}
            \]
            \quad
            \zsyseq{\Gamma}{\Delta_2, D}{\reactlist{2}}{B}
            \justifies
            \zsyseq{\Gamma}{\Delta, \Delta_1, \Delta_2,
              C \rightarrow_{\reactlist{}}^S D
            }{
              \baseandplus{\Delta_2}{\reactlist{}}{\reactlist{2}}
            }{B}
          \end{prooftree}
        \]

      \item Case the cut formula ends up in the right premise of the derivation
        of the right premise of the cut.

        \[
          \begin{prooftree}
            \zsyseq{\Gamma}{\Delta}{[]}{A}
            \qquad
            \[
              \zsyseq{\Gamma}{\Delta_1}{[]}{C}
              \qquad
              \zsyseq{\Gamma}{\Delta_2, A, D}{\reactlist{2}}{B}
              \justifies
              \zsyseq{\Gamma}{\Delta_1, \Delta_2, A, C \rightarrow_{\reactlist{}}^S
                D}{
                \baseandplus{(\Delta_2, A)}{\reactlist{}}{\reactlist{2}}
              }{B}
              \using{\resplist{(\Delta_2, A)}{\reactlist{}}}
            \]
            \justifies
            \zsyseq{\Gamma}{\Delta, \Delta_1, \Delta_2,
              C \rightarrow_{\reactlist{}}^S D
            }{
              \baseandplus{(\Delta_2, A)}{\reactlist{}}{\reactlist{2}}
            }{B}
          \end{prooftree}
        \]

        Then, by inductive hypothesis

        \[
          \begin{prooftree}
            \zsyseq{\Gamma}{\Delta_1}{[]}{C}
            \qquad
            \[
              \zsyseq{\Gamma}{\Delta}{[]}{A}
              \qquad
              \zsyseq{\Gamma}{\Delta_2, A, D}{\reactlist{2}}{B}
              \justifies
              \zsyseq{\Gamma}{\Delta, \Delta_2, D}{\reactlist{2}}{B}
            \]
            \justifies
            \zsyseq{\Gamma}{\Delta, \Delta_1, \Delta_2,
              C \rightarrow_{\reactlist{}}^S D
            }{
              \baseandplus{(\Delta_2, \Delta)}{\reactlist{}}{\reactlist{2}}
            }{B}
            \using{\resplist{(\Delta_2, \Delta)}{\reactlist{}}}
          \end{prooftree}
        \]

        Which gives the thesis, recalling that if
        $\zsyseq{\Gamma}{\Delta}{[]}{A}$, then
        $\elembases{\Delta} = \elembases{A}$ by Lemma.
      \end{enumerate}

    \item Case $\rightarrow R$. We can assume, as before, that the cut formula
      is active in the left premise. Then,

      \[
        \begin{prooftree}
          \zsyseq{\Gamma}{\Delta_1}{[]}{A}
          \qquad
          \[
            \zsyseq{\Gamma}{\Delta_2, A, B}{\reactlist{}}{C}
            \justifies
            \zsyseq{\Gamma}{\Delta_2, A}{[]}{
              B \rightarrow_{\reactlist{}}^{\elembases{\Delta_2,A}} C}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2}{
            []}{B \rightarrow_{\reactlist{}}^{\elembases{\Delta_2,A}} C}
        \end{prooftree}
      \]

      Then, by inductive hypothesis

      \[
        \begin{prooftree}
          \[
            \zsyseq{\Gamma}{\Delta_1}{[]}{A}
            \qquad
            \zsyseq{\Gamma}{\Delta_2, A, B}{\reactlist{}}{C}
            \justifies
            \zsyseq{\Gamma}{\Delta_1, \Delta_2, B}{\reactlist{}}{C}
          \]
          \justifies
          \zsyseq{\Gamma}{\Delta_1, \Delta_2}{
            []}{B \rightarrow_{\reactlist{}}^{\elembases{\Delta_1,\Delta_2}} C}
        \end{prooftree}
      \]

      which is just the thesis, recalling that if
      $\zsyseq{\Gamma}{\Delta}{[]}{A}$, then
      $\elembases{\Delta} = \elembases{A}$ by Lemma.
    \end{enumerate}
  \end{description}
\end{proof}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../docs"
%%% End:
